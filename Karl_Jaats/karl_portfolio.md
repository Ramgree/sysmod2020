# Systems modeling
## Karl Jääts

### Lecture 1
#### Preparation
Which types of diagrams are mentioned in the talk? <br>
Layered, UML, homeless c#, all kinds of non standard diagrams that people who don't know what they're doing have made <br>
<br>
What is the standard for modeling software mentioned in the movie? <br>
UML <br>
<br>
Why is nobody using it? <br>
Too complex, too low level, people don’t know it, they think agile and tdd is a replacement, because they make peoples heads hurt so they avoid them, no zoom in/out option <br>
<br>
What is the model-code gap and what is the problem with it? <br>
That the model shows different things than the code and you view them differently. The problem is that if the model and the code dont match then it is pointless to have the model. <br>
<br>
What do you personally think about layers for modeling software? <br>
The big, zoomed out, abstract layers I intuitively don't like, I find them to be difficult to understand and think they convey little actual information and thus are largely pointless/for show. The smaller, more zoomed in, implementation layers are necessary and a bit different. That being said I don't really have much experience with layers and software models so my opinion is very much subject to change. <br>
<br>
How do you think about Systems Modeling after watching this movie? <br>
A struggle and a necessary thing nobody really wants to do. <br>
<br>
Anything else remarkable from the movie, we should share/discuss? <br>
That modeling should involve more thinking on your own and not blindly following standards. <br>

#### Lecture tasks
What do you expect from Systems modeling? <br>
To understand systems modeling and make me a more well rounded developer. <br>
<br>
Architectures/modeling techniques I've already worked on? <br>
UML a bit, not much else. <br>
<br>
Who am i, why studing in SE masters? <br>
Estonian, liked programming in high school, studied it in bachleors and SE seemed like the direction to go, mainly because i wasn't very good/knowladeable about it while it seems like a crucial aspect of software development. <br>
<br>
What are my software development skills? <br>
Mainly programming (primarily java and python but a bunch of other stuff too), all kinds of bits and bobs i half remember from the bachleors degree. <br>
<br>
What are my weaknesses regarding software development? <br>
Formal planning and kinda the whole SE part of it. <br>
<br>
Software achitecture: <br>
Architecture is the fundamental organization of a system embodied in its components, their relationships to each other, and to the environment, and the principles guiding its design and evolution. [IEEE 1471] (https://www.ibm.com/developerworks/rational/library/feb06/eeles/index.html) <br>
Breakout partners: Daniel Nael, Jazib Sawar, Jekaterina, Rain Hallikas, Rasul Agharzayev, sergi <br>

#### Lecture reflection
First lecture in the new confusing situation so there was some trial and error, some stuff worked, some not much. In general there seemed to be a fair bit of jumping between different topics with a bunch of exercises mixed in which made it really hard to follow for me. I don't think I really learned much during it and think it should be taken a little more calmly, a little more traditionally. But in general that sort of style of lectures can work I think, it just needs a bit more refinement/adjustment. Plus this being the first lecture it was more of an admin lecture about the course and I think I kinda understand how the course will work, so the aims were mostly fulfilled so maybe I'm being a little hasty in my judgement.

#### Lab reflection
A very administrative lab so there's not much to say. Some of the lab exercises were pretty annoying and the learning aspect in them seemed pretty low.

### Lecture 2
#### Prep
##### Object Diagrams
**Pros:**
* Really close to implementation so it's easy to implement
* Can be used to really understand how the system works in practice <br>

**Cons:**
* Can only be used for a small system/part of system, otherwise it gets really big and hard to grasp
* Not applicable to not object oriented solutions <br>

**Example 1:** When trying to reverse engineer a program it makes sense to make a object diagram of it to understand whats happening better <br>
**Example 2:** When trying to structure a big project it doesn't make sense to use object diagrams as they are too 'zoomed in' <br>

#### Tasks
I was in breakout C. <br>
My main points were that object diagrams don't work with non object oriented solutions like functional programming and that they are easy to implement as the programmers doesn't really have to really invent anything themselves. <br>
The outcome for the breakout was that we found that the best points for and against object diagrams are: <br>
2 Best For: <br>
ODs are easy to implement. <br>
ODs are concrete and extremely easy to read and understand.  <br>
2 Best Against: <br>
ODs are hardly doable for large systems. <br>
ODs won’t work for non-object oriented solutions. <br>

#### Lecture reflection
It was good. Much better than the first one, the recorded/live hybrid seems to work really well. I'm still not sure about the breakouts into random groups because as an introvert I find that sort of situations difficult to engage in but I guess I'll manage. For that reason they also lose a bunch of time before they get going because people feel awkward and nobody wants to take charge.

